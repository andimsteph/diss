# -*- coding: utf-8 -*-
"""MC Test Control Draft

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QiBc0xnnzrvF-ISiMz7aZ8JLboH_z0km
"""

#Import packages
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

#This function creates a time series with n points, an autocorrelation of a,
#and a constant of ct

def create_time_series(n, a, ct):

    #Create an empty vector to hold values
    time_series = np.empty((0,))

    #Compute first point (no autocorrelation possible)
    point1 = np.random.normal(size = 1)

    #Add point1 to time series
    time_series = np.hstack((time_series, point1))

    #Repeat the process below for all subsequent points
    for i in range(1, n):

        #Compute autocorrelated point error term
        point = a*time_series[i-1]+np.random.normal(size = 1)

        #Add autcorrelated point to time series
        time_series = np.hstack((time_series, point))

    #Add constant to all points
    time_series = time_series + ct

    #Return the time series
    return(time_series)

#This function creates data for an alternating treatment graph with an
#autocorrelation of a, a trend of tr (in degrees), a constant of ct, a minimum
#of nb_points in each condition, a standardized mean difference of smd,
#and level of r in the control condition. Alternation is semi-random

def create_ME_data(a, tr, ct, nb_points, smd, r, alternation):

  if alternation == 'semi-random':

        #Empty vector for labels
        labels = np.empty((0,))

        #Repeat process for each pair of points
        for i in range(nb_points):

            #Randomly select the order of two conditions
            new_var = 2
            conditions = np.random.choice(['Control', 'Test'], 2, replace = False)

            #Add conditions to labels
            labels = np.hstack((labels, conditions))

        #Run code until minimum number of points is reached for both phases
        while (np.sum(labels == 'Control') < nb_points) | (np.sum(labels == 'Test') < nb_points):

            #Randomly select one condition
            condition = np.random.choice(['Control', 'Test'], 1)

            #Add condition to labels
            labels = np.hstack((labels, condition))

  #Create times series
  time_series = create_time_series(len(labels), a, ct)
  all_values = np.copy(time_series)

  #Indices for Phase A (Control)
  idxA = np.where(labels == 'Control')

  #Add r to values of Phase A
  all_values[idxA] += r

  #Indices for Phase B
  idxB, = np.where(labels == 'Test')

  #Add smd to values of Phase B
  all_values[idxB] = all_values[idxB] + smd + r

  #Identify middle point around which to pivot trend
  middle_point = np.median(range(len(all_values)))

  #Apply trend to all points
  for i in range(len(all_values)):

        #Compute distance to middle point for each point
        distance = i - middle_point

        #Add trend to each point using trigonometry (tangent of radians)
        all_values[i] = all_values[i] + distance*math.tan(tr*math.pi/180)

  #Combine labels and values in same list
  ME_data = [labels, all_values]

  #Return ME data
  return(ME_data)

#Function to produce ME graph

def ATgraph(ME_data):

    #Identify indices for Control and Test
    Control, = np.where(ME_data[0] == 'Control')
    Test, = np.where(ME_data[0] == 'Test')

    #Extract values for Control and Test
    valuesControl = ME_data[1][Control]
    valuesTest = ME_data[1][Test]

    #Initialize figure
    fig = plt.figure()
    ax = fig.add_subplot(111)

    #Plot data
    plt.plot(Control+1, valuesControl, 'ks-', label = 'Control')
    plt.plot(Test+1, valuesTest, 'ko-', label = 'Test')

    #Add axes titles
    plt.xlabel('Session')
    plt.ylabel('Behavior')

    #Add legend to graph
    ax.legend(loc='lower right', frameon=False)

    #Adjust height of graph
    plt.ylim(0, np.max(ME_data[1]*1.2))

    #Remove right and top borders
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

# Define ranges for each parameter
nb_points_list = [6, 10]
a_list = [0, 0.2]
tr_list = [-30, 0, 30]
smd_list = [0, 1, 2, 3]
r_list = [-5, 0, 5]
ct = 10


# Function to create data and graph
def perform_simulations():
  #Empty list to contain all the input data
  all_ME_data = []

  #Empty vector to contain the true values
  true_values = np.empty((0,))

  #Empty vector to contain trend values for each data series
  trend_values = np.empty((0,))

  #pp
  pp = PdfPages('MEgraphTest.pdf')

  # Loop over each combination of parameters
  for nb in nb_points_list:
       for a in a_list:
          for tr in tr_list:
              for smd in smd_list:
                  for r in r_list:
                      # Generate ME data for the set of parameters
                      ME_data = create_ME_data(a, tr, ct, nb, smd, r, 'semi-random')
                      # Plot graph
                      plt.figure()
                      ATgraph(ME_data)
                      # Title to distinguish different graphs
                      plt.title(f'nb_points={nb}, a={a}, tr={tr}, smd={smd}, r={r}')
                      #plt.show()
                      pp.savefig()
                      plt.close()

                      #Add data series to list
                      all_ME_data.append(ME_data)

                      #Add true value to vector
                      true_values = np.hstack((true_values, 1 if smd > 0 else 0))

                      #Add trend value to vector
                      trend_values = np.hstack((trend_values, tr))

  pp.close()

  return all_ME_data, true_values, trend_values

#Call
all_ME_data, true_values, trend_values = perform_simulations()

from google.colab import files
files.download('MEgraphTest.pdf')

# TEST - Setting parameters
test_params = {
    'a': 0.2,
    'tr': 0,
    'ct': 10,
    'nb_points': 6,
    'smd': 0,
    'r': -8,
    'alternation': 'semi-random'
}

# TEST - Generate ME data with parameters
ME_data = create_ME_data(
    test_params['a'],
    test_params['tr'],
    test_params['ct'],
    test_params['nb_points'],
    test_params['smd'],
    test_params['r'],
    test_params['alternation']
)

# TEST - Graph plotting
plt.figure
ATgraph(ME_data)
plt.title(f"Test Graph: {test_params}")
plt.show()
