# -*- coding: utf-8 -*-
"""Attempted 5 condition with UCL and LCL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Odk_JwQnTGcj9S96pMkYITMfG-cjgc1
"""

#Conducting Monte Carlo Simulations to Generate and Analyze Single-Case Graphs

#Import packages
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

#This function creates a time series with n points, an autocorrelation of a,
#and a constant of ct

def create_time_series(n, a, ct):

    #Create an empty vector to hold values
    time_series = np.empty((0,))

    #Compute first point (no autocorrelation possible)
    point1 = np.random.normal(size = 1)

    #Add point1 to time series
    time_series = np.hstack((time_series, point1))

    #Repeat the process below for all subsequent points
    for i in range(1, n):

        #Compute autocorrelated point error term
        point = a*time_series[i-1]+np.random.normal(size = 1)

        #Add autcorrelated point to time series
        time_series = np.hstack((time_series, point))

    #Add constant to all points
    time_series = time_series + ct

    #Return the time series
    return(time_series)

#This function creates data for an alternating treatment graph with an
#autocorrelation of a, a trend of tr (in degrees), a constant of ct, a minimum
#of nb_points in each condition, a standardized mean difference of smd,
#and level of r in the control condition. Alternation is semi-random

def create_ME_data(a, trControl, trAttention, trTangibles, trEscape, trAlone, ct, nb_points, smdAttention, smdTangibles, smdEscape, smdAlone, r, alternation):

  if alternation == 'semi-random':

        #Empty vector for labels
        labels = np.empty((0,))

        #Repeat process for each pair of points
        for i in range(nb_points):

            #Randomly select the order of 5 conditions
            new_var = 5
            conditions = np.random.choice(['Control', 'Attention', 'Tangibles', 'Escape', 'Alone'], 5, replace = False)

            #Add conditions to labels
            labels = np.hstack((labels, conditions))

        #Run code until minimum number of points is reached for all phases
        while (np.sum(labels == 'Control') < nb_points) | (np.sum(labels == 'Attention') < nb_points)| (np.sum(labels == 'Tangibles') < nb_points)| (np.sum(labels == 'Escape') < nb_points)| (np.sum(labels == 'Alone') < nb_points):

            #Randomly select one condition
            condition = np.random.choice(['Control', 'Test', 'Tangibles', 'Escape', 'Alone'], 1)

            #Add condition to labels
            labels = np.hstack((labels, condition))

  #Create times series
  time_series = create_time_series(len(labels), a, ct)
  all_values = np.copy(time_series)

  #Indices for Phase A (Control)
  idxControl = np.where(labels == 'Control')[0]

  #Indices for Attention
  idxAttention = np.where(labels == 'Attention')[0]

  #Indices for Tangibles
  idxTangibles = np.where(labels == 'Tangibles')[0]

  #Indices for Escape
  idxEscape = np.where(labels == 'Escape')[0]

  #Indices for Alone
  idxAlone = np.where(labels == 'Alone')[0]

  #Add smd to values of test conditions
  all_values[idxAttention] += smdAttention
  all_values[idxTangibles] += smdTangibles
  all_values[idxEscape] += smdEscape
  all_values[idxAlone] += smdAlone

  #Identify middle point around which to pivot trend
  middle_point = np.median(range(len(all_values)))

  #Apply trend to all points separately
  #Control
  for j in range(len(idxControl)):
    distance = idxControl[j] - middle_point
    all_values[idxControl[j]] += distance * math.tan(trControl * math.pi / 180)

  #Phase Attention
  for j in range(len(idxAttention)):
        distance = idxAttention[j] - middle_point
        all_values[idxAttention[j]] += distance * math.tan(trAttention * math.pi / 180)

  #Phase Tangibles
  for j in range(len(idxTangibles)):
        distance = idxTangibles[j] - middle_point
        all_values[idxTangibles[j]] += distance * math.tan(trTangibles * math.pi / 180)

  #Phase Escape
  for j in range(len(idxEscape)):
        distance = idxEscape[j] - middle_point
        all_values[idxEscape[j]] += distance * math.tan(trEscape * math.pi / 180)

  #Phase Alone
  for j in range(len(idxAlone)):
        distance = idxAlone[j] - middle_point
        all_values[idxAlone[j]] += distance * math.tan(trAlone * math.pi / 180)

  #Set max and min values, and normalize
  min_value = np.min(all_values)
  max_value = np.max(all_values)
  all_values = (all_values - min_value) / (max_value - min_value) * 10

  #Recalculate smd
  mean_control = np.mean(all_values[idxControl])
  mean_attention = np.mean(all_values[idxAttention])
  mean_tangibles = np.mean(all_values[idxTangibles])
  mean_escape = np.mean(all_values[idxEscape])
  mean_alone = np.mean(all_values[idxAlone])

  current_smd_attention = mean_attention - mean_control
  current_smd_tangibles = mean_tangibles - mean_control
  current_smd_escape = mean_escape - mean_control
  current_smd_alone = mean_alone - mean_control

  #Adjust values to maintain smd
  #Attention
  if current_smd_attention != smdAttention:
      adjustment = smdAttention - current_smd_attention
      all_values[idxAttention] += adjustment / 2
      all_values[idxControl] -= adjustment / 2

  #Tangibles
  if current_smd_tangibles != smdTangibles:
      adjustment = smdTangibles - current_smd_tangibles
      all_values[idxTangibles] += adjustment / 2
      all_values[idxControl] -= adjustment / 2

  #Escape
  if current_smd_escape != smdEscape:
      adjustment = smdEscape - current_smd_escape
      all_values[idxEscape] += adjustment / 2
      all_values[idxControl] -= adjustment / 2

  #Alonw
  if current_smd_alone != smdAlone:
      adjustment = smdAlone - current_smd_alone
      all_values[idxAlone] += adjustment / 2
      all_values[idxControl] -= adjustment / 2

  #Set max and min values, and normalize (to ensure positive values)
  min_value = np.min(all_values)
  max_value = np.max(all_values)
  all_values = (all_values - min_value) / (max_value - min_value) * 10

  #add r after normalization to increase level
  all_values[idxControl] += r
  all_values[idxAttention] += r
  all_values[idxTangibles] += r
  all_values[idxEscape] += r
  all_values[idxAlone] += r

  #Combine labels and values in same list
  ME_data = [labels, all_values]

  #Return ME data
  return(ME_data)

#Function to produce ME graph

def ATgraph(ME_data, trControl, trAttention, trTangibles, trEscape, trAlone):

    #Identify indices for all conditions
    Control, = np.where(ME_data[0] == 'Control')
    Attention, = np.where(ME_data[0] == 'Attention')
    Tangibles, = np.where(ME_data[0] == 'Tangibles')
    Escape, = np.where(ME_data[0] == 'Escape')
    Alone, = np.where(ME_data[0] == 'Alone')

    #Extract values for each condition
    valuesControl = ME_data[1][Control]
    valuesTest = ME_data[1][Attention]
    valuesTestB = ME_data[1][Tangibles]
    valuesTestC = ME_data[1][Escape]
    valuesTestD = ME_data[1][Alone]

    #Calculate mean and sd of control
    meanControl = np.mean(valuesControl)
    stdControl = np.std(valuesControl)

    #Initialize figure
    fig = plt.figure()
    ax = fig.add_subplot(111)

    #Plot data
    plt.plot(Control+1, valuesControl, 'ks-', label = 'Control')
    plt.plot(Attention+1, valuesTest, 'ko-', label = 'Attention')
    plt.plot(Tangibles+1, valuesTestB, 'go-', label = 'Tangibles')
    plt.plot(Escape+1, valuesTestC, 'ro-', label = 'Escape')
    plt.plot(Alone+1, valuesTestD, 'bo-', label = 'Alone')

    #Add axes titles
    plt.xlabel('Session')
    plt.ylabel('Behavior')

    #Add legend to graph
    ax.legend(loc='upper right', frameon=False)

    #Adjust height of graph
    plt.ylim(0, np.max(ME_data[1]*1.5))

    #Remove right and top borders
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)

    #Plot UCL and LCL
    if meanControl == 0:
        plt.axhline(y=0, color='b', linestyle='--', label='UCL/LCL at 0')
    else:
        plt.axhline(y=meanControl + stdControl, color='b', linestyle='--', label='UCL')
        plt.axhline(y=meanControl - stdControl, color='b', linestyle='--', label='LCL')

# Define ranges for each parameter
nb_points_list = [6, 10]
a_list = [0, 0.2]
tr_list_Control = [0, 0, 0] #determine number of 0s, angle of trend from effect size data
tr_list_Attention = [-30, 0, 30]
tr_list_Tangibles = [-30, 0, 30]
tr_list_Escape = [-30, 0, 30]
tr_list_Alone = [-30, 0, 30]
smd_list_Attention = [0, 3, 6]
smd_list_Tangibles = [0, 3, 6]
smd_list_Escape = [0, 3, 6]
smd_list_Alone = [0, 3, 6]
r_list = [0, 2, 4]
ct = 10


# Function to create data and graph
def perform_simulations():

  #Empty list to contain all the input data
  all_ME_data = []

  #Empty vector to contain the true values
  true_values = np.empty((0,))

  #Empty vector to contain trend values for each data series
  trend_values = np.empty((0, 5))

  #pp
  pp = PdfPages('ME5graphTest.pdf')

  # Loop over each combination of parameters
  for nb in nb_points_list:
       for a in a_list:
          for trControl in tr_list_Control:
              for trAttention in tr_list_Attention:
                  for trTangibles in tr_list_Tangibles:
                      for trEscape in tr_list_Escape:
                          for trAlone in tr_list_Alone:
                              for smdAttention in smd_list_Attention:
                                  for smdTangibles in smd_list_Tangibles:
                                      for smdEscape in smd_list_Escape:
                                          for smdAlone in smd_list_Alone:
                                              for r in r_list:

                                                  # Generate ME data for the set of parameters
                                                  ME_data = create_ME_data(a=a, trControl=trControl, trAttention=trAttention, trTangibles=trTangibles, trEscape=trEscape, trAlone=trAlone, ct=ct, nb_points=nb, smdAttention=smdAttention, smdTangibles=smdTangibles, smdEscape=smdEscape, smdAlone=smdAlone, r=r, alternation='semi-random')

                                                  # Plot graph
                                                  plt.figure()
                                                  ATgraph(ME_data, trControl, trAttention, trTangibles, trEscape, trAlone)

                                                  # Title to distinguish different graphs
                                                  plt.title(f'nb_points={nb}, a={a}, trControl={trControl}, trAttnention={trAttention}, trTangibles={trTangibles},trEscape={trEscape},trControl={trControl}, smdAttention={smdAttention}, smdTangibles={smdTangibles}, smdEscape={smdEscape}, smdAlone={smdAlone}, r={r}')

                                                  #plt.show()
                                                  pp.savefig()
                                                  plt.close()

                                                  #Add data series to list
                                                  all_ME_data.append(ME_data)

                                                  #Determine true values
                                                  smd_values = [smdAttention, smdTangibles, smdEscape, smdAlone]
                                                  count_greater_than_zero = sum(1 for smd in smd_values if smd > 0)
                                                  true_value = 2 if count_greater_than_zero >= 2 else (1 if count_greater_than_zero == 1 else 0)

                                                  #Add trend value to vector
                                                  trend_values = np.vstack((trend_values, np.array([[trControl, trAttention, trTangibles, trEscape, trAlone]])))

                                                  #Add true value to vector
                                                  true_values = np.hstack((true_values, true_value))

  pp.close()

  return all_ME_data, true_values, trend_values

#Call
all_ME_data, true_values, trend_values = perform_simulations()



